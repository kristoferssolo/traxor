mod netspeed;

use transmission_rpc::types::{ErrorType, Torrent, TorrentGetField, TorrentStatus};
mod filesize;
use filesize::FileSize;
use netspeed::NetSpeed;

pub trait Wrapper {
    fn title(&self) -> String {
        String::from("")
    }

    fn value(&self, torrent: Torrent) -> String {
        format!("{}", torrent.name.unwrap_or(String::from("")))
    }

    fn width(&self) -> u16 {
        0
    }
}

impl Wrapper for TorrentGetField {
    fn title(&self) -> String {
        match self {
            Self::ActivityDate => String::from("Activity Date"),
            Self::AddedDate => String::from("Added Date"),
            Self::Availability => todo!(),
            Self::BandwidthPriority => todo!(),
            Self::Comment => todo!(),
            Self::CorruptEver => todo!(),
            Self::Creator => todo!(),
            Self::DateCreated => todo!(),
            Self::DesiredAvailable => todo!(),
            Self::DoneDate => String::from("Done Date"),
            Self::DownloadDir => String::from("Path"),
            Self::DownloadLimit => todo!(),
            Self::DownloadLimited => todo!(),
            Self::DownloadedEver => todo!(),
            Self::EditDate => String::from("Edit Date"),
            Self::Error => String::from("Error Type"),
            Self::ErrorString => String::from("Error String"),
            Self::Eta => String::from("ETA"),
            Self::EtaIdle => todo!(),
            Self::FileCount => todo!(),
            Self::FileStats => String::from("File Stats"),
            Self::Files => String::from("Files"),
            Self::Group => todo!(),
            Self::HashString => String::from("Hash String"),
            Self::HaveUnchecked => todo!(),
            Self::HaveValid => todo!(),
            Self::HonorsSessionLimits => todo!(),
            Self::Id => String::from("Id"),
            Self::IsFinished => String::from("Finished"),
            Self::IsPrivate => String::from("Private"),
            Self::IsStalled => String::from("Stalled"),
            Self::Labels => String::from("Labels"),
            Self::LeftUntilDone => String::from("Left Until Done"),
            Self::MagnetLink => todo!(),
            Self::ManualAnnounceTime => todo!(),
            Self::MaxConnectedPeers => todo!(),
            Self::MetadataPercentComplete => String::from("Metadata Percent Complete"),
            Self::Name => String::from("Name"),
            Self::PeerLimit => todo!(),
            Self::Peers => todo!(),
            Self::PeersConnected => String::from("Connected"),
            Self::PeersFrom => todo!(),
            Self::PeersGettingFromUs => String::from("Peers"),
            Self::PeersSendingToUs => String::from("Seeds"),
            Self::PercentComplete => todo!(),
            Self::PercentDone => String::from("%"),
            Self::PieceCount => todo!(),
            Self::PieceSize => todo!(),
            Self::Pieces => todo!(),
            Self::PrimaryMimeType => todo!(),
            Self::Priorities => String::from("Priorities"),
            Self::QueuePosition => String::from("Queue"),
            Self::RateDownload => String::from("Download Speed"),
            Self::RateUpload => String::from("Upload Speed"),
            Self::RecheckProgress => String::from("Progress"),
            Self::SecondsDownloading => todo!(),
            Self::SecondsSeeding => String::from("Seconds Seeding"),
            Self::SeedIdleLimit => todo!(),
            Self::SeedIdleMode => todo!(),
            Self::SeedRatioLimit => String::from("Seed Ratio Limit"),
            Self::SeedRatioMode => String::from("Seed Ratio Mode"),
            Self::SequentialDownload => todo!(),
            Self::SizeWhenDone => String::from("Size"),
            Self::StartDate => todo!(),
            Self::Status => String::from("Status"),
            Self::TorrentFile => String::from("Torrent File"),
            Self::TotalSize => String::from("Total Size"),
            Self::TrackerList => todo!(),
            Self::TrackerStats => todo!(),
            Self::Trackers => String::from("Trackers"),
            Self::UploadLimit => todo!(),
            Self::UploadLimited => todo!(),
            Self::UploadRatio => String::from("Ratio"),
            Self::UploadedEver => String::from("Uploaded"),
            Self::Wanted => String::from("Wanted"),
            Self::Webseeds => todo!(),
            Self::WebseedsSendingToUs => String::from("Webseeds Sending to Us"),
        }
    }

    fn value(&self, torrent: Torrent) -> String {
        match self {
            Self::ActivityDate => optional_to_string(torrent.activity_date),
            Self::AddedDate => optional_to_string(torrent.added_date),
            Self::Availability => todo!(),
            Self::BandwidthPriority => todo!(),
            Self::Comment => todo!(),
            Self::CorruptEver => todo!(),
            Self::Creator => todo!(),
            Self::DateCreated => todo!(),
            Self::DesiredAvailable => todo!(),
            Self::DoneDate => optional_to_string(torrent.done_date),
            Self::DownloadDir => optional_to_string(torrent.download_dir),
            Self::DownloadLimit => todo!(),
            Self::DownloadLimited => todo!(),
            Self::DownloadedEver => todo!(),
            Self::EditDate => optional_to_string(torrent.edit_date),
            Self::Error => match torrent.error {
                Some(error) => match error {
                    ErrorType::Ok => String::from("Ok"),
                    ErrorType::LocalError => String::from("LocalError"),
                    ErrorType::TrackerError => String::from("TrackerError"),
                    ErrorType::TrackerWarning => String::from("TrackerWarning"),
                },
                None => String::from("N/A"),
            },
            Self::ErrorString => optional_to_string(torrent.error_string),
            Self::Eta => match torrent.eta {
                Some(eta) => match eta {
                    -1 => "".into(),
                    -2 => "?".into(),
                    _ => format!("{} s", eta),
                },
                None => String::from(""),
            },
            Self::EtaIdle => todo!(),
            Self::FileCount => todo!(),
            Self::FileStats => match torrent.file_stats {
                Some(file_stats) => file_stats
                    .iter()
                    .map(|x| format!("{:?}", x.priority))
                    .collect(),
                None => String::from("N/A"),
            },
            Self::Files => match torrent.files {
                Some(files) => files.iter().map(|x| x.name.to_owned()).collect(),
                None => String::from("N/A"),
            },
            Self::Group => todo!(),
            Self::HashString => optional_to_string(torrent.hash_string),
            Self::HaveUnchecked => todo!(),
            Self::HaveValid => todo!(),
            Self::HonorsSessionLimits => todo!(),
            Self::Id => optional_to_string(torrent.id),
            Self::IsFinished => optional_to_string(torrent.is_finished),
            Self::IsPrivate => optional_to_string(torrent.is_private),
            Self::IsStalled => optional_to_string(torrent.is_stalled),
            Self::Labels => match torrent.labels {
                Some(labels) => labels.join(" "),
                None => String::from("N/A"),
            },
            Self::LeftUntilDone => FileSize(torrent.left_until_done.unwrap_or(0)).to_string(),
            Self::MagnetLink => todo!(),
            Self::ManualAnnounceTime => todo!(),
            Self::MaxConnectedPeers => todo!(),
            Self::MetadataPercentComplete => optional_to_string(torrent.metadata_percent_complete),
            Self::Name => optional_to_string(torrent.name),
            Self::PeerLimit => todo!(),
            Self::Peers => todo!(),
            Self::PeersConnected => optional_to_string(torrent.peers_connected),
            Self::PeersFrom => todo!(),
            Self::PeersGettingFromUs => optional_to_string(torrent.peers_getting_from_us),
            Self::PeersSendingToUs => optional_to_string(torrent.peers_sending_to_us),
            Self::PercentComplete => todo!(),
            Self::PercentDone => match torrent.percent_done {
                Some(percent_done) => format!("{:.0}", percent_done * 100.0),
                None => String::from("N/A"),
            },
            Self::PieceCount => todo!(),
            Self::PieceSize => todo!(),
            Self::Pieces => todo!(),
            Self::PrimaryMimeType => todo!(),
            Self::Priorities => match torrent.priorities {
                Some(priorities) => priorities.iter().map(|x| format!("{:?}", x)).collect(),
                None => String::from("N/A"),
            },
            Self::QueuePosition => String::from("N/A"),
            Self::RateDownload => NetSpeed(torrent.rate_download.unwrap_or(0)).to_string(),
            Self::RateUpload => NetSpeed(torrent.rate_upload.unwrap_or(0)).to_string(),
            Self::RecheckProgress => optional_to_string(torrent.recheck_progress),
            Self::SecondsDownloading => todo!(),
            Self::SecondsSeeding => optional_to_string(torrent.seconds_seeding),
            Self::SeedIdleLimit => todo!(),
            Self::SeedIdleMode => todo!(),
            Self::SeedRatioLimit => optional_to_string(torrent.seed_ratio_limit),
            Self::SeedRatioMode => String::from("N/A"),
            Self::SequentialDownload => todo!(),
            Self::SizeWhenDone => FileSize(torrent.size_when_done.unwrap_or(0)).to_string(),
            Self::StartDate => todo!(),
            Self::Status => match torrent.status {
                Some(status) => match status {
                    TorrentStatus::Stopped => String::from("Stopped"),
                    TorrentStatus::Seeding => String::from("Seeding"),
                    TorrentStatus::Verifying => String::from("Verifying"),
                    TorrentStatus::Downloading => String::from("Downloading"),
                    TorrentStatus::QueuedToSeed => String::from("QueuedToSeed"),
                    TorrentStatus::QueuedToVerify => String::from("QueuedToVerify"),
                    TorrentStatus::QueuedToDownload => String::from("QueuedToDownload"),
                },
                None => String::from("N/A"),
            },
            Self::TorrentFile => optional_to_string(torrent.torrent_file),
            Self::TotalSize => FileSize(torrent.total_size.unwrap_or(0)).to_string(),
            Self::TrackerList => todo!(),
            Self::TrackerStats => todo!(),
            Self::Trackers => match torrent.trackers {
                Some(trackers) => trackers.iter().map(|x| x.announce.to_string()).collect(),
                None => String::from("N/A"),
            },
            Self::UploadLimit => todo!(),
            Self::UploadLimited => todo!(),
            Self::UploadRatio => match torrent.upload_ratio {
                Some(upload_ratio) => format!("{:.2}", upload_ratio),
                None => String::from("N/A"),
            },
            Self::UploadedEver => FileSize(torrent.uploaded_ever.unwrap_or(0)).to_string(),
            Self::Wanted => match torrent.wanted {
                Some(wanted) => wanted.iter().map(|x| x.to_string()).collect(),
                None => String::from("N/A"),
            },
            Self::Webseeds => todo!(),
            Self::WebseedsSendingToUs => String::from("N/A"),
        }
    }

    fn width(&self) -> u16 {
        match self {
            Self::ActivityDate => 10,
            Self::AddedDate => 10,
            Self::Availability => todo!(),
            Self::BandwidthPriority => todo!(),
            Self::Comment => todo!(),
            Self::CorruptEver => todo!(),
            Self::Creator => todo!(),
            Self::DateCreated => todo!(),
            Self::DesiredAvailable => todo!(),
            Self::DoneDate => 10,
            Self::DownloadDir => 30,
            Self::DownloadLimit => todo!(),
            Self::DownloadLimited => todo!(),
            Self::DownloadedEver => todo!(),
            Self::EditDate => 10,
            Self::Error => 10,
            Self::ErrorString => 10,
            Self::Eta => 10,
            Self::EtaIdle => todo!(),
            Self::FileCount => todo!(),
            Self::FileStats => 10,
            Self::Files => 10,
            Self::Group => todo!(),
            Self::HashString => 10,
            Self::HaveUnchecked => todo!(),
            Self::HaveValid => todo!(),
            Self::HonorsSessionLimits => todo!(),
            Self::Id => 10,
            Self::IsFinished => 10,
            Self::IsPrivate => 10,
            Self::IsStalled => 10,
            Self::Labels => 10,
            Self::LeftUntilDone => 10,
            Self::MagnetLink => todo!(),
            Self::ManualAnnounceTime => todo!(),
            Self::MaxConnectedPeers => todo!(),
            Self::MetadataPercentComplete => 10,
            Self::Name => 70,
            Self::PeerLimit => todo!(),
            Self::Peers => todo!(),
            Self::PeersConnected => 10,
            Self::PeersFrom => todo!(),
            Self::PeersGettingFromUs => 10,
            Self::PeersSendingToUs => 10,
            Self::PercentComplete => todo!(),
            Self::PercentDone => 10,
            Self::PieceCount => todo!(),
            Self::PieceSize => todo!(),
            Self::Pieces => todo!(),
            Self::PrimaryMimeType => todo!(),
            Self::Priorities => 10,
            Self::QueuePosition => 10,
            Self::RateDownload => 10,
            Self::RateUpload => 10,
            Self::RecheckProgress => 10,
            Self::SecondsDownloading => todo!(),
            Self::SecondsSeeding => 10,
            Self::SeedIdleLimit => todo!(),
            Self::SeedIdleMode => todo!(),
            Self::SeedRatioLimit => 10,
            Self::SeedRatioMode => 10,
            Self::SequentialDownload => todo!(),
            Self::SizeWhenDone => 10,
            Self::StartDate => todo!(),
            Self::Status => 15,
            Self::TorrentFile => 10,
            Self::TotalSize => 10,
            Self::TrackerList => todo!(),
            Self::TrackerStats => todo!(),
            Self::Trackers => 10,
            Self::UploadLimit => todo!(),
            Self::UploadLimited => todo!(),
            Self::UploadRatio => 10,
            Self::UploadedEver => 10,
            Self::Wanted => 10,
            Self::Webseeds => todo!(),
            Self::WebseedsSendingToUs => 10,
        }
    }
}

fn optional_to_string<T: ToString>(option: Option<T>) -> String {
    option.map_or_else(|| "N/A".into(), |val| val.to_string())
}
